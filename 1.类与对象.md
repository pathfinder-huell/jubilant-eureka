# [1.类与对象]() 

**类里面有访问权限, 行为, 属性 ,函数。把这些封装成一个类，Tips: 类中的属性和行为等称为成员。**

# 2.创建对象

**要创建一个对象需要先封装一个类，随后用类实例化一个对象。		例：类名 对象;**	

```
class Dog {
public:
    string name;
    Dog(string n) {
        name = n;
        cout << "构造了一只叫 " << name << " 的狗狗！\n";
    }
};
int main() {
    Dog d("旺财"); 	//通过类，实例化一个对象
}
```

# 3.访问权限控制	

**访问权限有三个:**

* 公共权限 **public**	     	 **成员 类内可以访问 类外可访问**  

* 保护权限 **protected**	**成员 类内可以访问 类外不可访问	子类 可以 访问父类中的保护内容**
* 私有权限  **private**           **成员 类内可以访问 类外不可访问	子类 无法 访问父类中的私有内容**

# 4.成员属性私有控制

**1.私有可以直接控制读写权限** 		**2.私有可以检测写入数据有效性**

**通过私有让类以外的操作无法直接影响到成员属性，读写通过写类似 回调函数 的操作进行读写。**

```
class Person
{
public:
	void setName(string name)   //获取name，输出到私有类中的成员更改函数。 写
	{
		m_Name = name;			//调用setName函数就会将你放进去的函数转而放进成员属性
	}
	string getName()			//输出名字的函数。读 
	{
		return m_Name;			//调用getName函数就返回m_name成员属性
	}
	int age()					//只读
	{ 
		return  m_Age;			//调用age函数就会返回m_Age成员属性
	 }

	void setIdol(string idol)	//只写
	{
		m_Idol = idol;			//调用此函数会把你写入setIdol中的值转而放进m_Idol成员属性
	}
private:
	string m_Name;	 //可读可写
	int m_Age=19;	 //只读
	string m_Idol;	 //只写
};
```

# 5.构造函数语法：类名(  ){  }

**1.构造函数，没有返回值也不写void**
**2.函数名称与类名相同**

###### **3.构造函数可以有参数可重载**

4.程序**在调用对象时候**会自动调用构造，无需手动调用，且只会调用一次，在你不手动创建的情况下，系统会生成一个空构造函数

## **5.1构造函数的分类及调用规则**

**如果写了一个拷贝构造函数，在没有写其他构造函数的情况下，系统就不会再给出任何构造函数了。**

**如果写了一个有参构造函数，在没有写其他构造函数的情况下，系统就不会给出无参(默认)构造函数，但是还是会给出默认拷贝构造函数。**

**两种分类方式:**
按参数分为: 有参构造和无参构造
按类型分为: 普通构造和拷贝构造
**三种调用方式:**

 **1.括号法（最常用）**

```
Person p1;       // 默认构造
Person p2(18);   // 有参构造
Person p3(p2);   // 拷贝构造
❗ 注意事项：
无参构造不能写成 Person p1();，会被认为是一个函数声明。
```

 **2.显示法** 

```
Person p2 = Person(10);     // 有参构造
Person p3 = Person(p2);     // 拷贝构造
✅ 特点：创建一个临时对象后，再拷贝给新对象。构造 & 拷贝都可调用。
```

 **3.隐式转换法**

> ```
> Person p4 = 10;    // 等价于 Person p4 = Person(10);
> Person p5 = p4;    // 等价于 Person p5 = Person(p4);
> ✅ 特点：`= 值` 会自动进行类型转换（调用构造函数生成对象）
> ```
>
> ⚠️ `Person(p5);` 不能直接这么写（拷贝构造匿名对象），会被编译器认为是函数声明。

**匿名对象**



## 5.2拷贝构造函数

拷贝构造函数用于用一个已有对象去初始化另一个新对象。

**1.语法：**

```
Person(const Person& p) {	 const 类型& p 保证不修改这个对象 的情况下对被传入的对象取了一个别名p 
    age = p.age;	   		 通过别名p.age 调用被传入的成员属性，拷贝到我的身上。
    cout << "拷贝构造函数被调用" << endl;
}
```

####      **2.拷贝构造调用时机：**

1. **用一个对象初始化另一个对象：`Person p2 = p1;`**

2. **将对象作为参数传递给函数：`void fun(Person p);`** 

   ​		**当你把 `p1` 传给 `fun` 函数的参数时，参数 `p` 是一个 新对象，它需要被初始化为 `p1` 的副本，所以：**

   > **✅ 会调用拷贝构造函数创建 `p`。**

   #### **💡 为什么是拷贝？**

   ​		**因为 `Person p` 是按值传参（不是引用或指针），所以需要拷贝出一个独立的副本给函数使用。副本在函数结束时销毁。**

3. 从函数返回对象：`return p;`

   **`	return p2;` 会把局部对象 `p2` 拷贝一份（拷贝构造函数调用一次）**

4. 显示调用拷贝构造：`Person p3(p1);`

####       **3.系统默认提供拷贝构造：**

如果你不提供，编译器会默认生成一个**浅拷贝**构造函数。

> ✅ 浅拷贝：简单粗暴地把一个对象的**所有字节内容原样复制**到另一个对象中，包括指针成员的地址
>
> ✅ 深拷贝：会为指针成员分配新空间并复制内容，本质就是不让地址重复，所以只要是含有指针地址传递属性的拷贝就需要使用深拷贝，比如new开辟的新空间地址，数组，函数类型。

#### 除此以外，也需要在析构函数中对你在堆区所开辟的空间进行释放.

✅ 总结一下：

| 情况           | 是否用 new | 是否崩溃 | 原因                                                |
| -------------- | ---------- | -------- | --------------------------------------------------- |
| 使用指针 + new | 是         | 会崩溃   | 拷贝构造导致两个对象共享堆区地址，析构时重复 delete |
| 不使用指针     | 否         | 不会崩溃 | 值拷贝，系统自动处理                                |

# 6.析构函数语法: ~类名(  ){  }

1.析构函数，没有返回值也不写void
2.函数名称与类名相同,在名称前加上符号,
3.析构函数不可以有参数，因此不可以发生重载, 
4.**程序在对象销毁前**会自动调用析构，无须手动调用,而且只会调用一次在你不手动创建的情况下，系统会生成一个析构造函数， 

# 7.初始化列表

C++提供了初始化列表语法，用来初始化属性
语法:构造函数(): 属性1(值1)属性2(值2)...{}

```
	Person(int a,int b,int c) :m_A(a), m_B(b), m_C(c)  //形参给列表中属性赋值
	{
	}
	Person p(30,20,10);		//调用
```

# 8.类对象作为类成员

当其他类对象作为本类成员，构造时候先构造类对象，，析构的顺序与构造相反

# 9. 静态成员

## 9.1 **静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员**,静态成员分为: 静态成员显函数与静态成员变量

## 9.2 静态成员变量

**静态成员变量的所有对象共享同一份数据，在编译阶段分配内存.**

**🎉声明：在类内声明，类外初始化**		**Tips:权限控制 🚩类外访问不到私有静态成员变量**

```c++
class Person
{
public:			}
	static int m_A; 
};
int Person:: m_A = 100;
```

💡所有对象都共享同一份数据，静态成员变量不属于某个对象上    因此 静态成员变量有两种访问方式。

1.通过对象进行访问      

```c++
Person p;
cout << p.m_A<<endl;
```

  2.通过类名进行访问 例如类名::静态变量名

```c++
cout << Person::m_A << endl;
```

## 9.3  静态成员显函数

**静态成员函数所有对象共享同一个函数，静态成员函数只能访问静态成员变量**

**也有两种方式访问，与上列同理**			**Tips: 权限控制 🚩类外访问不到私有静态成员函数**

**♿使用方式：静态成员函数只能访问静态成员变量**

	static void func(){
		m_A = 100; //是静态成员，可以访问静态函数
		//m_B = 200;//不是静态成员 ，无法访问静态函数
	}
	static int m_A;
	int m_B;	}；

# 10. C++对象模型和this指针

## 10.1 成员变量和成员函数分开存储

在C++中，类的成员变量和成员函数是分开储存的，静态成员变量不属于类对对象，动态的才是

编译器会给每个**空对象**分配一个字节空间，为了区分**空对象**占的内存位置，

```
int m_A;	   //非静态成员变量 属于类的对象上
static int m B;//静态成员变量 不属于类对象上
void func(){}  //非静态成员函数 不属于类对象上
static void func2(){} //静态成员函数 不属于类的对象上
```

## 10.2 this指针概念

**this指针谁调用他，他就指向谁** (this指针指向被调用的成员函数所属的对象)

**this指针不用定义,他隐藏于不是静态成员函数内 **(this指针是隐含在每一个非静态成员函数内的一种指针)

this指针不需要定义，直接使用即可

### 💡用途

**1. 当你的形参和成员变量同名时，可以用this指针区分他们**

**在类中不是静态成员函数返回对象本身，使用return *this**就可以实现链式编程

```
class Person{			     //1.解决名称冲突
public:
	Person(int age)		//当有对象调用函数，this指向调用此函数的对象
	{					//this指针指向被调用的成员函数所属的对象
	this->age =  age; 	//所以这个被this指向的age指向了对象
	}
	int age;	
};		
//2.返回对象本身，使用解引用*this
```

2.返回对象本身用*this

```
void PersonAddAge(Person &p)
{
	this->age = this->age + p.age   //将自身的age，加上被放进去对象的age
}
使用return *this**
void test02( )
{
	Person p1(10);		
	Person p2(10);
	p2.PersonAddAge(p1); //this 指向p2，将传入函数中的p1加给了p2.
}
```

## 10.3空指针访问成员函数

**可以指向成员函数，但是需要注意的情况**

**空指针没有指向任何实例化对象，此时访问的成员函数中如果有属性，属性默认被this指针指向，那么此时你没有对象来调用成员属性，this指针是不是就是空的了，哪你空的指针调用空的this指向的成员属性是不是就调用不到了？**

```
void showPersonAge()
{	//报错原因是因为传入的指针为空
    if(this = =NULL){ //防止空指针传入影响
        return;
    }
	cout<<"age = "<< m_Age <<endl; //属性前面默认会有一个this
}
int m_Age; 
```

总结：空指针在调用成员函数时，如果内有属性，属性中自带的this无法获取到对象之后，就会报错。

## 10.4 const修饰成员函数

常函数 

cosnt修饰后面的函数叫做常函数，常函数的内部**成员属性**无法修改

但是**成员属性声明**时加上mutable之后，就可以修改了

### 常对象

声明对象前加const的对象叫常对象，常对象只能调用常函数

# 11.友元

友元的目的就是让一个函数或者类 访问另一个类中私有成员、

友元的关键字为friend

## 11.1全局函数做友元

在你需要访问的类中最顶部加上声明，并且加上friend全局函数识别 : friend void 函数名() ;告诉编译器，你写的全局函数是友元

## 11.2类做友元

与上面同理，在要访问的私有内容类顶端加上 friend	class 类名

**tips** 类外声明成员函数这样写     类名 : : 函数名 

## 11.3成员函数做友元

同上，加上friend 但因为是成员函数的特殊性，要让编译器认识你成员函数还得加上 类名 :: 函数名

# 12. 运算符重载

重载有两种方式，一种是成员函数，一种是全局函数。

**作用**：让自定义的类对象可以像内置类型（int、double）一样使用运算符。

系统只认识内置类型的 `+、-、==、<<` 等，如果我们想让自己的类也支持这些运算，就要自己告诉编译器怎么做。

## 12.1加号运算符重载

利用系统默认重载函数名：operator+

## 12.2 左移运算符重载

一般不用成员函数重载左移运算符

左移默认名为：operator

作用是自定义输出，不用每次输出都调用对象属性，而是直接输出对象就把里面属性全部打印了，简洁

使用ostream输出流配合引用方式调用cout，实现cout在场上只有一个 ，并且保持cout在左，对象在右

## 12.3递增运算符重载

先把左移运算符实现作为输出基础，在进行重载前置++ 与 重载后置++部署

```
// 前置递增
Counter& operator++() {
    ++m_val;      // 先加
    return *this; // 返回自己（引用）
}

```

```
// 后置递增，需要一个int占位参数区分
Counter operator++(int) {
    Counter temp = *this; // 先保存旧值
    ++m_val;              // 自增
    return temp;          // 返回旧值
}

```

## 12.4 赋值运算符重载

**c++编译器至少给一个类添加4个函数**

1.默认构造函数(无参，函数体为空)
2.默认析构函数(无参，函数体为空)
3.默认拷贝构造函数，对属性进行值拷贝
4.赋值运算符 operator=,对属性进行值拷贝

但如果类中有属性指向了堆区，那么在做赋值操作时也会出现深浅拷贝问题 

编译器默认给出的是浅拷贝操作，如果有属性在堆区，析构函数释放时，就会出现堆区重复释放错误。 所以需要写一个赋值运算符重载

要先看被赋值对象有没有堆区内存，有的话先清空，然后进行深拷贝。

如果要实现连等于操作呢，我们需要返回对象自身。以及返回值也得为对象的引用。

```
person& operator= (person &p) //返回值也得为对象自身。
{
if(m_Age != NULL)
	{
		delete m_Age;
		m_Age = NULL;
	}
	m_Age = new int (*p.m_Age)
	
	return *this; //返回对象自身
}
```

## 12.5 关系运算符重载

重载关系运算符可以让两个自定义对像对比

关键词 operator ==   operator != 

# 13.继承

## 13.1继承的基本语法

语法   class 子类 : 继承方式 父类

子类父类也称派生类与基类.

子类中的成员有两大部分：

第一是从父类继承过来的，一类是自己增加的成员。

从父类继承来的表现为一致性，而自己新增的成员有自己的特性。

## 13.2继承方式

继承方式有三种：

**公共，保护，私有**

如果父类有公共保护私有属性成员。

**在公共继承方式下，除了私有不可访问，其余与父类无区别**

**在保护继承下，除了私有不可访问，其余全部归到保护权限下**

**在私有继承下除了私有不可访问，，其余全归于私有权限下**

tips:保护权限无法在类外访问。

## 13.3继承中的对象模型

父类中所有非静态成员属性全部会被子类继承

父类中的私有成员属性也算在继承内存中，不过访问不到被编译器隐藏了。

## 13.4继承中构造与析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数

**顺序为先构造父类，在构造子类，析构相反，先析构子类，在析构父类。**

## 13.5继承同名成员处理方式

要访问子类同名成员，直接访问即可

**要通过子类对象访问到父类中同名成员， 需要加作用域 对象名.父类:: 同名成员**

**子类与父类的成员函数出现同名，子类的成员函数会隐藏掉父类的全部同名成员函数.如果需要调用，需要加作用域    对象名.父类:: 函数名**

## 13.6继承同名静态成员处理方式。

 与上方同理，但静态分为对象调用与类名调用

通过类名稍有不同，作用域为子 :: 父 :: 成员函数/成员属性

## 13.7多继承语法

  c++允许一个类继承多个类

```
语法： class 子类: 继承方式 父类1，继承方式 父类2......
```

多继承中可能会有父类中有同名成员出现，需要加作用域区分

C++实际开发中一般不使用。

如果出现父类成员同名成员，同样加上作用域解决。

## 13.8菱形继承

**概念： 两个子类继承同一个父类，又有某一个类同时继承这俩子类，这种继承被叫做菱形继承，或者钻石继承**

问题会有：

**底层继承类继承了两个类，当底层使用时会出现二义性。可通过作用域解决。**

**底层继承了两份类，但只需要一份避免资源浪费** **那么就使用虚继承解决 在继承前加virtual 关键字变为虚继承**

**此时公共的父类称为虚父类，虚基类。**

# 14.多态

## 14.1多态基本概念

多态是C++面向对象三大特性之一

**多态分为两类 :**

1. 静态多态 : 函数重载和运算符重载属于静态多态，复用函数名
2. 动态多态 : 派生类和虚函数实现运行时多态

**静态多态与动态多态区别 :**

1. 静态多态的函数地址早绑定 - 编译阶段就确定函数地址
2. 动态多态的函数地址晚绑定 - 运行阶段才确认函数地址

 **多态满足条件**
1.·有继承关系
2.子类重写父类中的虚函数
**多态使用条件**
1.父类指针或引用 指向子类对象

# 模板15

C++提供两种模板机制:函数模板和类模板

## 15.1函数模板语法

函数模板作用:

建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。

语法：

```
template<typename T>
函数声明或定义
```

解释:

template ----声明创建模板

typename ---数据类型，可用class代替

T ---通用的数据类型，名称可以替换。

## 15.2 特性

自动类型推导，显式指定类型

**通用数据类型** **T** 会自动推导你的数据类型

 指定类型<int>(a,b)，指定通用数据类型为int

注意自动类型推导必须保持数据一致性

模板必须明确数据类型，才可运行

## 15.3普通函数与函数模板的区别

### 最好是使用显示指定方式调用模板

普通函数调用时可以发生自动类型转换(隐式类型转换)

函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换

如果利用显示指定类型的方式，可以发生隐式类型转换

## 15.4普通函数与模板的调用规则

1.函数模板也可以发生重载

2.函数模板与普通函数都可实现重载，系统优先调用普通函数

3.可以通过空模板参数列表强制调用	函数模板

4.函数模板比普通函数更好适配，则优先调用函数模板

**既然提供了模板，最好就别使用普通函数了，容易出现二义性**

## 15.5模板的局限性

利用具体化的模板，可以解决自定义类型的通用化I
学习模板并不是为了写模板，而是在STL能够运用系统提供的模板

**模板具体化**：是给“模板函数/类”写特例。

**运算符重载**：是给“类”加运算语义。

**模板具体化解决**： “模板遇到特殊类型”无法正常工作的情况

**运算符重载**： 让对象像内置类型一样使用运算符、

# 16类模板

类模板语法

建立一个通用类，类中的数据类型，成员可以不具体指定，用一个虚拟的类型来代表

语法:

```c++
template <typename T>
类
```

## 16.1类模板与函数模板的区别

类模板没有自动推导使用法

类模板在参数列表中可以有默认的参数类型

类模板中的成员函数并不是一开始就创建的，在调用时才去创建

## 16.2类模板对象做函数参数

底层目标：类模板实例化的对象向函数传参的方式

**通过类模板创建的对象，可以有三种方式向函数中进行传参**

**1.指定传入类型		 ---直接显示对象中的数据类型**

```
//1,指定传入类型
void printPerson1(Person<string, int>&p) //this
{
	p.showPerson();
}
void test01()
{
	Person<string,int>p("孙悟空", 12);
	printPerson1(p);
	//p.showPerson();
}
```

**2.参数模板化 			--- 将对象中的参数变为模板再传递**

```
//2.参数模板化
template<class T1,class T2>
void printPerson2(Person<T1, T2> &p) //this
{
	p.showPerson();
}
void test02()
{
Person<string, int>p("猪八戒", 90);
printPerson2(p);
}
```

**3.整个类的模板化 	 ---将这个对象类型模板化进行传递**

```
template<class T>
void printPerson3(T &p) //this 将整个类型化为模板
{
	p.showPerson();
	cout << "T type :" << typeid(T).name() << endl;
}
void test03() 
{
	Person<string, int> p("ts", 30);
	printPerson3(p);
}

```

使用比较广泛的是：指定传入的类型

**2.3两种其实就是添加了一个函数模板配和类模板实现灵活的类型传递。**

## 获取自动推导出的T是什么数据类型   ---- typeid(T).name()；

## 16.3类模板与继承

1. **子类继承的父类是一个类模板，那么子类声明的时候**

2. **如果不指定，编译器无法给予子类分配内存**

3. **如果想灵活指定出父类中T的类型，那么子类也得变更为模板** 子类示例对象指定模板传到父类，子类继承父类，子类获得刚刚传递过去的类型。

   

## 16.4类模板成员函数类外实现

底层目标：能够掌握类模板中的成员函数类外实现

类模板中的成员函数在类外实现的时候，得加上模板的参数列表

```
//构造函数类外实现
template <class T1,class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
	this->m_Name = name;
	this->m_Age = age;
}

//成员函数的类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson()
{
	cout << "姓名: " << this->m_Name << "年龄 :" << this->m_Age << endl;
}
```

## 16.5类模板分文件编写

掌握类模板成员函数分文件编写产生的问题以及解决方式

**问题：**

- **类模板中成员函数创建时机是在调用阶段，导致文件编写时连接不到**
- 解决方式1:直接包含.cpp源文件
  解决方式2:将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制
- 总结:主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp


## 16.6类模板与友元

- 掌握类模板配合友元函数的类内和类外实现

- 全局函数类内实现-直接在类内声明友元即可

- 全局函数类外实现-需要提前让编译器知道全局函数的存在






# 类模板自定义数组案例

## 🔹 1. 三法则（Rule of Three）

如果一个类需要自己管理资源（比如 `new` / `delete`），通常要写三个函数：

1. **析构函数** `~ClassName()`
2. **拷贝构造函数** `ClassName(const ClassName&)`
3. **拷贝赋值运算符** `ClassName& operator=(const ClassName&)`

因为只要涉及到堆内存管理，默认的“浅拷贝”就会出问题。



## 2.需求：实现一个通用数组类

1. **自定义存储各种数据类型**
2. **将数组数据存放在堆区**
3. **自定义容量**
4. **提供尾插法尾删法对数组中的数据增删**









# 一.STL 认识

## 1.STL的出生

- 大多数情况下，数据结构和算法都没有一套标准。导致被迫重复大量同等工作
- 为了数据结构和算法有一套标准保持复用性，发明了STL

## 2.STL基本概念

- **STL**: 大体上来看，STL是容器，算法，迭代器组成的。
- 容器与算法之间，通过迭代器进行无缝连接。
- STL的几乎所有代码都有模板参与。

## 3.STL六大组件

STL大体可分为：**容器，算法，迭代器，仿函数，适配器，空间配置器**

1.容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据

2.算法：各种常用算法，如sort、find、copy、for_each等

3.迭代器：扮演容器与算法之间的粘合剂

4.仿函数：行为类似函数，可作为算法的某种策略

5.适配器：一种修饰容器或者仿函数以及迭代器接口的东西。

6.空间配置器：负责空间的配置与管理。

## 4.STL容器、算法、迭代器

**STL容器**的数据结构不同，存放的内容也有所不同

这些容器分为序列式容器和关联式容器两种：

​	**序列式容器**：强调值的排序，容器中每个元素均有固定的位置。无自动排序

​	**关联式容器：**二叉树结构，各元素之间没有严格物理上的顺序关系。自动排序



​	**算法** 分为质变算法与非质变算法

**质变算法**：是值运算过程期间会更改区间内的元素内容。比如拷贝，替换，删除等

**非质变算法**：运算过程中不会更改区间内的元素内容，比如查找，技术，遍历等



**迭代器**：容器和算法之间的粘合剂

提供一种方法，让算法通过迭代器访问到容器，但是又不会暴露容器的内部方法。

每个容器都有独有的迭代器

迭代器使用类似指针，初学先以指针理解迭代器。

## 5.认识vector

容器: vector

算法： for_each

迭代器: vector<int>::iterator

```
//vector<int>::iterator itBegin = v.begin();//起始迭代去 指向容器中第一个元素
//vector<int>::iterator itEnd = v.end();//结束迭代器 指向容器中最后一个元素的下一个位置

	////第一种遍历方式
	//while (itBegin != itEnd)
	//{
	//	cout << *itBegin << endl;
	//	itBegin++;
	//}

	////第二种遍历方式
	//for(vector<int>::iterator it=v.begin();it!=v.end();it++)

	//	{
	//		cout<<*it<<endl;
	//	}

	//第三种 利用STL提供的遍历算法
	for_each(v.begin(), v.end(), myPrint); 此myPrint是一个自定义函数。
```



## 5.1 vector存放自定义数据类型

解引用出的是外层vector内尖括号的内容。



## 5.2 vector容器套容器

重点在于怎么使用vector插入与使用迭代器输出，解引用出的是外层vector内尖括号的内容。



# 二.常用容器之string

string是c++风格的字符串，而string本质是一个类

**string和cha*r区别**

char* 是一个指针

string 是一个类，类内部封装了char*,管理这个字符串，是一个char *型的容器

**特点：**

string类内部封装了很多成员方法

**例如**：find，copy，delete,replace,insert

string 管理char * 所分配的内存，不用担心复制越界和取值越界等，由内部进行负责

## 1.string构造函数

```
string();					创建一个空的字符串 例如:string str;
string(const char* s);		使用字符串s初始化
string(const string& str);	使用一个string对象初始化另外一个string对象
string(int n,char c);		使用n个字符c初始化
```



# 排序算法 

总体来说，设置内外两层循环，每次循环都找出最值，多次循环后最值按判定输出为最大或最小排序进行交换。

